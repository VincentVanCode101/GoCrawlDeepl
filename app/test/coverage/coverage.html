
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>deepl: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">crawl/deepl/main.go (0.0%)</option>
				
				<option value="file1">crawl/deepl/utils/browser/chrome_context.go (0.0%)</option>
				
				<option value="file2">crawl/deepl/utils/cliargs/argsfilter.go (100.0%)</option>
				
				<option value="file3">crawl/deepl/utils/envutil/envutil.go (100.0%)</option>
				
				<option value="file4">crawl/deepl/utils/network/internet_check.go (0.0%)</option>
				
				<option value="file5">crawl/deepl/utils/telegrambot/telegrambot_util.go (0.0%)</option>
				
				<option value="file6">crawl/deepl/utils/url/deepl_url_builder.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

        "crawl/deepl/utils/browser"
        "crawl/deepl/utils/cliargs"
        "crawl/deepl/utils/envutil"
        "crawl/deepl/utils/network"
        "crawl/deepl/utils/telegrambot"
        "crawl/deepl/utils/url"

        "github.com/chromedp/cdproto/cdp"
        "github.com/chromedp/chromedp"
)

const (
        baseURL = "https://www.deepl.com/en/translator#"
        xpath   = `//*[@id="textareasContainer"]/div[3]/section/div[1]/d-textarea/div/p/span`
)

// Translation holds the phrase to be translated along with its translations.
type Translation struct {
        toBeTranslatedPhrase string
        translatedPhrases    []string
}

// TelegramBot encapsulates the details needed to interact with the Telegram bot API.
type TelegramBot struct {
        bot    *tgbotapi.BotAPI
        chatID int64
}

func main() <span class="cov0" title="0">{
        totalExecTime := time.Now()

        fromLang, toLang, err := envutil.GetLanguages()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to retrieve languages from environment: %v", err)
        }</span>

        <span class="cov0" title="0">toBeTranslatedPhrases, err := cliargs.FilterNonEmptyArgs()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">if err := network.CheckInternetConnection(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to establish an internet connection: %v", err)
        }</span>

        <span class="cov0" title="0">chromeCtx, cancelChrome, cancelExecAllocator, err := browser.GetChromeContext()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize Chrome context: %v", err)
        }</span>
        <span class="cov0" title="0">defer cancelExecAllocator()
        defer cancelChrome()

        bot, chatID, err := telegrambot.SetupTelegramBot()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to initialize Telegram bot: %v", err)
                return // the program should continue without the telegram-sending funcionality, thats why we just log and not abort here
        }</span>

        <span class="cov0" title="0">var telegramBot *TelegramBot
        if bot != nil </span><span class="cov0" title="0">{
                telegramBot = &amp;TelegramBot{bot: bot, chatID: chatID}
        }</span>

        <span class="cov0" title="0">fmt.Printf("Amount of unrelated words to translate %d: %s\n", len(toBeTranslatedPhrases), strings.Join(toBeTranslatedPhrases, ", "))
        for _, toBeTranslatedPhrase := range toBeTranslatedPhrases </span><span class="cov0" title="0">{
                handleTranslation(chromeCtx, toBeTranslatedPhrase, fromLang, toLang, telegramBot)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Total execution time of the program: %v\n\n", time.Since(totalExecTime))</span>
}

func handleTranslation(chromeCtx context.Context, toBeTranslatedPhrase string, fromLang string, toLang string, telegrambot *TelegramBot) <span class="cov0" title="0">{

        startTime := time.Now()

        translation := Translation{
                toBeTranslatedPhrase: toBeTranslatedPhrase,
                translatedPhrases:    []string{},
        }

        var deeplURL string = url.BuildDeeplURL(baseURL, fromLang, toLang, translation.toBeTranslatedPhrase)

        translatedPhrases, err := runTranslationTask(chromeCtx, deeplURL, xpath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">translation.translatedPhrases = append(translation.translatedPhrases, translatedPhrases...)

        outputTranslation(translation, telegrambot)

        fmt.Printf("Execution time: %v\n\n", time.Since(startTime))</span>
}

func formatTranslation(input string, translations []string) string <span class="cov0" title="0">{
        return fmt.Sprintf("Input:\n%s\n\nMain translation:\n%s", input, strings.Join(translations, "\n"))
}</span>

func outputTranslation(translation Translation, telegramBot *TelegramBot) <span class="cov0" title="0">{
        text := formatTranslation(translation.toBeTranslatedPhrase, translation.translatedPhrases)

        // if telegramBot != nil {
        //         msg := tgbotapi.NewMessage(telegramBot.chatID, text)
        //         if _, err := telegramBot.bot.Send(msg); err != nil {
        //                 log.Printf("Failed to send message via Telegram bot: %v", err)
        //         }
        // }
        fmt.Println("---------------------------------")
        fmt.Println(text)
        fmt.Println("---------------------------------")
}</span>

func runTranslationTask(ctx context.Context, url, xpath string) ([]string, error) <span class="cov0" title="0">{
        var nodes []*cdp.Node
        if err := chromedp.Run(ctx,
                chromedp.Navigate(url),
                chromedp.WaitVisible(xpath),
                chromedp.Nodes(xpath, &amp;nodes, chromedp.BySearch),
        ); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return getTextFromNodes(ctx, nodes)</span>
}

func getTextFromNodes(ctx context.Context, nodes []*cdp.Node) ([]string, error) <span class="cov0" title="0">{
        var translatedTexts []string
        for _, node := range nodes </span><span class="cov0" title="0">{
                var text string
                if err := chromedp.Run(ctx, chromedp.Text(node.FullXPath(), &amp;text)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">translatedTexts = append(translatedTexts, text)</span>
        }
        <span class="cov0" title="0">return translatedTexts, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package browser

import (
        "context"
        "errors"

        "github.com/chromedp/chromedp"
)

func buildChromeOptions(headless, disableGPU, startMaximized bool) []chromedp.ExecAllocatorOption <span class="cov0" title="0">{
        options := []chromedp.ExecAllocatorOption{
                chromedp.ExecPath("/usr/bin/google-chrome"),
                chromedp.Flag("headless", headless),
                chromedp.Flag("disable-gpu", disableGPU),
                chromedp.Flag("start-maximized", startMaximized),
                chromedp.NoSandbox,
        }
        return append(chromedp.DefaultExecAllocatorOptions[:], options...)
}</span>

func getChromeExecAllocatorContext(opts []chromedp.ExecAllocatorOption) (context.Context, context.CancelFunc, error) <span class="cov0" title="0">{
        ctx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)
        if ctx == nil </span><span class="cov0" title="0">{ // Typically you'd check an actual error, not just a nil context, but chromedp.NewExecAllocator() does not return an err
                return nil, nil, errors.New("failed to create Chrome executor allocator")
        }</span>
        <span class="cov0" title="0">return ctx, cancel, nil</span>
}

// GetChromeContext initializes and returns a Chrome browser context for web scraping.
func GetChromeContext() (context.Context, context.CancelFunc, context.CancelFunc, error) <span class="cov0" title="0">{
        opts := buildChromeOptions(true, true, true)
        execAllocCtx, cancelExecAllocator, err := getChromeExecAllocatorContext(opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">chromeCtx, cancelChrome := chromedp.NewContext(execAllocCtx)
        if chromeCtx == nil </span><span class="cov0" title="0">{ // Again, you'd typically check an error, not context
                cancelExecAllocator()
                return nil, nil, nil, errors.New("failed to create Chrome context")
        }</span>
        <span class="cov0" title="0">return chromeCtx, cancelChrome, cancelExecAllocator, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cliargs

import (
        "errors"
        "log"
        "os"
        "strings"
)

// FilterNonEmptyArgs processes command-line arguments to remove empty values and returns a cleaned list or an error if none are provided.
func FilterNonEmptyArgs() ([]string, error) <span class="cov8" title="1">{

        var allCliArgs []string = os.Args[1:]
        if len(allCliArgs) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("no cli args provided")
        }</span>
        <span class="cov8" title="1">log.Printf("Lenght of cli args: %v\n", len(allCliArgs))
        log.Printf("The cli args are: %v\n", allCliArgs)

        neededCliArgs := allCliArgs[0]
        var words []string = strings.Split(neededCliArgs, "\n")
        var nonEmptyWords []string

        for _, word := range words </span><span class="cov8" title="1">{
                trimmedWord := strings.TrimSpace(word)
                if trimmedWord != "" </span><span class="cov8" title="1">{
                        nonEmptyWords = append(nonEmptyWords, trimmedWord)
                }</span>
        }

        <span class="cov8" title="1">if len(nonEmptyWords) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("no non-empty cli args provided")
        }</span>

        <span class="cov8" title="1">return nonEmptyWords, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package envutil

import (
        "log"
        "os"
)

// GetLanguages retrieves the FROM_LANGUAGE and TO_LANGUAGE from the environment variables.
func GetLanguages() (string, string, error) <span class="cov8" title="1">{
        fromLang, isPresent := os.LookupEnv("FROM_LANGUAGE")
        if !isPresent || fromLang == "" </span><span class="cov8" title="1">{
                log.Println("No environment variable for FROM_LANGUAGE found. Defaulting to 'en'.")
                fromLang = "en"
        }</span>

        <span class="cov8" title="1">toLang, isPresent := os.LookupEnv("TO_LANGUAGE")
        if !isPresent || toLang == "" </span><span class="cov8" title="1">{
                log.Println("No environment variable for TO_LANGUAGE found. Defaulting to 'de'.")
                toLang = "de"
        }</span>

        <span class="cov8" title="1">return fromLang, toLang, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package network

import (
        "errors"
        "net"
        "time"
)

// CheckInternetConnection verifies if the internet connection is available.
func CheckInternetConnection() error <span class="cov0" title="0">{
        const googleDNS = "8.8.8.8:53"
        const timeout = 5 * time.Second

        conn, err := net.DialTimeout("tcp", googleDNS, timeout)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("no internet connection: unable to connect to Google's DNS server")
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package telegrambot

import (
        "fmt"
        "log"
        "os"
        "strconv"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// SetupTelegramBot initializes and configures a new Telegram bot.
func SetupTelegramBot() (*tgbotapi.BotAPI, int64, error) <span class="cov0" title="0">{
        botToken, isPresent := os.LookupEnv("BOT_TOKEN")
        if !isPresent || botToken == "" </span><span class="cov0" title="0">{
                log.Println("No environment variable for BOT_TOKEN found. Telegram bot will not be used.")
                return nil, 0, nil
        }</span>

        <span class="cov0" title="0">chatIDStr, isPresent := os.LookupEnv("CHAT_ID")
        if !isPresent || chatIDStr == "" </span><span class="cov0" title="0">{
                log.Println("No environment variable for CHAT_ID found. Telegram bot will not be used.")
                return nil, 0, nil
        }</span>

        <span class="cov0" title="0">chatID, err := strconv.ParseInt(chatIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("error converting CHAT_ID to int64: %v", err)
        }</span>

        <span class="cov0" title="0">bot, err := tgbotapi.NewBotAPI(botToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to create bot: %v", err)
        }</span>

        <span class="cov0" title="0">return bot, chatID, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package url

import (
        "fmt"
        "net/url"
        "strings"
)

// BuildDeeplURL constructs a URL for accessing the DeepL translation service.
func BuildDeeplURL(baseURL, fromLang, toLang, phraseToTranslate string) string <span class="cov8" title="1">{
        escapedPhrase := url.QueryEscape(phraseToTranslate)
        finalEscapedPhrase := strings.ReplaceAll(escapedPhrase, "+", "%20")
        return fmt.Sprintf("%s%s/%s/%s", baseURL, fromLang, toLang, finalEscapedPhrase)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
